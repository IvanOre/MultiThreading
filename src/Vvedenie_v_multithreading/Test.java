package Vvedenie_v_multithreading;

/**
 * Многопоточность позволяет выполнять код параллельно с другим кодом.Каждый поток берет на себя определенную задачу
 * что позволяет выполнять несколько действий одновременно.
 *  Одноядерный процессор.Это происходит когда процессор быстро переключается
 * между потоками тем самым создавая видимость,что разные действия выполнятся параллельно.Виртуальная параллельность
 * В многоядерном компе все еще быстрее. Распределение по ядрам.
 * ОСновная цель многопоточности ускорить выполнение задач. Какие то цели выполняются в фоновом режиме пока основная
 * выполняется и тд и тп.Тот же веб-сервер не может без многопоточности. В нем происходит много операций
 * одновременно(разные запросы-ответы и тд) Для каждого клиента свой поток создается.
 *
 *
 * 2 способа создать поток.
 *
 * 1 способ это создать класс и наследоваться от класса Thread
 * Нам нужно переопределить метод run() и в нем описать функционал потока.
 * Потом создам наш поток в мейн методе. и запускаем его через метод .start(). Не через run(). ОН для внутреннего
 * использования.
 * Когда запускаем метод start() в методе main, то запускается где-то поток.И в нем начинает выполнятся код который
 * мы описали в методе run().А в потоке main который вызвали через start() этот вызов мгновенно завершается и поток
 * main продолжает свою работу и продолжает выполнение инструкции  System.out.println("Hello from main Thread");
 * Почему он выполнился раньше всех?
 * Создался MyThread-вызвал метод start()-мгновенно из него вернулся-вывел на экран сообщение "Hello from main Thread"
 *и потом начал выполнение в потоке MyThread()-и он уже вывел "Hello from MyThread"
 * Потоки в Жаве не синхронизированный по умолчанию. Выполняются в любом порядке.потоки борются за выполнение
 * Создали второй поток в мейн. и когда выводим в консоль то видим как потоки борются за выполнение задачи
 *
 * Метод sleep(1000) усыпляет поток на заданное кол-во времени(указываем в мс).Может вызываться в главном потоке
 *
 *
 *
 *  public static void main(String[] args) {
 *         MyThread myThread = new MyThread();
 *         myThread.start();
 *
 *     }
 * }
 *
 * class MyThread extends Thread{
 *     public void run(){
 *         for (int i = 0; i < 1000; i++){
 *             System.out.println("Hello from MyThread");
 *         }
 *
 *     }
 *
 * }
 *
 *
 * 2 способ создания потока
 * В своем классе реализуем Runnable и в методе run() реализуем логику которую хотим видеть и передаем этот
 * класс в конструктор при создании нового Thread
 * Мы реализовали логику в методе run() от интерфейса Runnable и передаем ее в наш новый Thread передав в
 * аргументы наш класс Runner реализовывающий интерфейс Runnable
 *
 *
 *
 *
 *
 *
 */
public class Test {
    public static void main(String[] args) throws InterruptedException {
        // создание потоков через 2 способ
        Thread thread = new Thread(new Runner());// создали новый поток и в аргумент передали наш класс
        thread.start();
        System.out.println("Hello from main thread");








        // 1 способ создания потоков
        /*MyThread myThread = new MyThread();
        myThread.start();

        Thread.sleep(1000);// поспим секунду. и увидим что 1 поток начнет первым тк второй начнет работу через 1 секунду

        MyThread myThread2 = new MyThread();// создаем второй поток в мейн
        myThread2.start();*/

        /*System.out.println("I am going to sleep");
        Thread.sleep(3000);
        System.out.println("I am awake");*/

        //System.out.println("Hello from main Thread");


    }
}
// 2 способ создания потока через интерфейс Runnable
class Runner implements Runnable{

    @Override
    public void run() {
        for (int i = 0; i < 1000; i++){
            try {
                Thread.sleep(1000);// потоки будут работать с интервалами в 3 секунды на каждой итерации
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println("Hello from MyThread" + i);
        }


    }
}



// 1 способ создания потока
class MyThread extends Thread{
    public void run(){
        for (int i = 0; i < 1000; i++){
            try {
                Thread.sleep(3000);// потоки будут работать с интервалами в 3 секунды на каждой итерации
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println("Hello from MyThread" + i);
        }

    }

}
