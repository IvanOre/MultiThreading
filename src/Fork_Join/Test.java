package Fork_Join;

import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.RecursiveAction;

/**
 * Fork/Join для разделяемых рекурсивных задач удобен. Принцип Разделяй и Властвуй.
 * Fork/join это реализация ExecutorService
 * Мы свою большую задачу делим на части. Не обязательно равные. Но стоит избегать совсем деления на маленькие части.
 * Тк это не ускорит выполнение программы. А наоборот может навредить
 *
 *
 * Свободные потоки крадут работу у других.
 * Проще говоря, свободные потоки пытаются “украсть” работу у деков занятых потоков.
 *
 * По умолчанию рабочий поток получает задачи из головы своего собственного deque. Когда он пуст, поток берет задачу из хвоста
 * deque другого занятого потока или из глобальной очереди ввода, так как именно здесь, вероятно, будут расположены самые
 * большие части работы.
 *
 * Такой подход сводит к минимуму вероятность того, что потоки будут конкурировать за задачи. Это также сокращает количество
 * раз, когда потоку придется искать работу, так как сначала он работает с самыми большими доступными фрагментами работы.
 *
 * RecursiveAction выполняет действия без возвращения какого-либо результата.
 * RecursiveTask может еще вернуть значение.
 *
 * 3. ForkJoinTask
 * ForkJoinTask является базовым типом для задач, выполняемых внутри ForkJoinPool. На практике следует расширить один из
 * двух его подклассов: RecursiveAction для void задач и RecursiveTask для задач, возвращающих значение. У них обоих есть
 * абстрактный метод compute () , в котором определена логика задачи.
 *
 * 4. Отправка задач в ForkJoinPool
 * Для отправки задач в пул потоков можно использовать несколько подходов.
 *
 * Метод submit() или execute ()
 * Метод invoke() разветвляет задачу и ожидает результата, и не требует ручного соединения:
 * Метод invokeAll() является наиболее удобным способом отправки последовательности ForkJoinTasks в ForkJoinPool.
 * Он принимает задачи в качестве параметров (две задачи, varargs или коллекция), а затем возвращает коллекцию объектов
 * Feature в том порядке, в котором они были созданы.
 *
 * Кроме того, вы можете использовать отдельные методы fork() и join () . Метод fork() отправляет задачу в пул, но не запускает
 * ее выполнение. Для этой цели необходимо использовать метод join () . В случае RecursiveAction функция join() возвращает
 * только null ; для RecursiveTask возвращает результат выполнения задачи
 *
 *
 * Использование фреймворка fork/join может ускорить обработку больших задач, но для достижения этого результата необходимо
 * следовать некоторым рекомендациям:
 *
 * Используйте как можно меньше пулов потоков – в большинстве случаев лучшим решением является использование одного пула
 * потоков для каждого приложения или системы
 *
 * Используйте пул общих потоков по умолчанию, если конкретная настройка не требуется
 *
 * Используйте разумный порог для разделения ForkJoinTask на подзадачи
 *
 * Избегайте каких-либо блокировок в вашей Forkjointask
 *
 *
 * Используем рекурсивный алгоритм(RecursiveAction or RecursiveTask) и делим задачу на какие-то другие
 * подзадачи(MyAction m1 = new MyAction(value / 2); и сбрасываем их в очередь. Оттуда их достают потоки и выполняют.
 * Если задача порождает опять какие-то вещи,то обратно в очередь и потоки опять с ней работают. Потом задачи закончатся,
 * потоки освободятся и это значит ,что наша задача разделенная на много более мелких,отработала и закончена.Наш синхронный
 * вызов invoke() закончен.
 *
 *
 *
 *
 *
 */
public class Test {
    public static void main(String[] args) {
        final int MAX = 64;// задали константу переменной

        ForkJoinPool pool = new ForkJoinPool(16);// создали потоки. их кол-во равно кол-ву ядер процессора. можем указать вручную
        pool.invoke( new MyAction(MAX));// отдаем одну задачу и ждем завершения задач
        System.out.println("FINISH");

    }
}

class MyAction extends RecursiveAction {
    private int value;

    public MyAction(int value) {
        this.value = value;
    }

    @Override
    protected void compute() {// реализовали метод RеcursiveAction
        if (value <= 4){// если значение меньше или равно 4 то выводим сообщение с id потока который работает с задачей
            System.out.println("Hello before: " + Thread.currentThread().getId() + " " + value);
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {

            }

            System.out.println("Hello after: " + Thread.currentThread().getId() + " " + value);
        }else {// если больше 4 ,то создадим еще деление этого значения на 2(можно на любое число пос ути)
            MyAction m1 = new MyAction(value / 2);
            MyAction m2 = new MyAction(value / 2);
            invokeAll(m1,m2);// invoke вызывает задачу. invokeAll все задачи.

        }

    }
}
