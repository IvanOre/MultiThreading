package Synchronized1;

/**
 * 2 и более потоков пишут в 1 переменную
 * Synchronized
 *
 * join работает так.Когда идем в нашем главном потоке Main,когда запускаем doWork(),поток доходит до вызова
 * .start, вызывает эти 2 потока,и если бы не вызвали на этих потоках join() ,они мгновенно бы вывели
 * переменную в консоль.Но мы хотим подождать пока эти 2 потока полностью завершат свою работу. Это нам как раз
 * и помогает сделать вызов .join() на потоках. Тогда вывод точно не будет равен 0. но и 20000 тоже не будет равно
 * всегда. Нет синхронизации потоков.У нас состояние гонки.Race condition. и часть инкриментов теряется.
 *
 * Наглядно есть 2 потока.
 * 1: 100->101-запись в каунтер 101 уже->102->103 и тд.
 *
 * 2 поток запоздал допустим и может пропустить n-итераций цикла
 * 2: 100->101-и тоже запись в канутер(а должно было 102 тк уже был инкримент в потоке1)
 *
 * Потоки не связаны и поэтому вывод не всегда 20000. Не атомарны операции.
 * Как можно исправить эту проблему. Существует ключевое слово synchronized
 *
 * создали метод для инкриментирования переменной и в нем обозначили ключевое слово synchronized
 *
 *     public synchronized void increment(){
 *         counter++;
 *
 *     }
 *
 * Как работает synchronized?
 * Только один поток в момент времени получает доступ к выполнению метода. А другой поток ждет. Как 1 поток закончит
 * дается доступ 2 потоку к методу и он его тоже исполняет
 *
 *  Каждому объекту в Джаве после создания присваивается сущность. Монитор. И эта сущность в одни момент времени
 *  может быть только у одного потока. Для синхронизации нужен объект.
 *
 *
 *
 *
 *
 */
public class Test {
    private int counter;
    public static void main(String[] args) throws InterruptedException {
        Test test = new Test();
        test.doWork();

    }
//создали метод для инкриментирования переменной и в нем обозначили ключевое слово synchronized
    public synchronized void increment(){
        counter++;
    }

    public void doWork() throws InterruptedException {// в этом методе 2 потока инкриментируют одну и ту же переменную counter
        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 10000; i++)
                    increment();// юзаем метод вместо привычных ++
            }
        });

        Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 10000; i++)
                    increment();
            }
        });

        thread1.start();// может выводиться 0
        thread2.start();

        thread1.join();
        thread2.join();

        System.out.println(counter);

    }
}
