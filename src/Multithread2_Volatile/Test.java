package Multithread2_Volatile;

import java.util.Scanner;

/**
 * Хаотичность потоков нам не подходит. Хотим стабильность в работе потоков.
 *
 *Ключевое слово volatile помогает в синхронизации потоков.Означает изменчивый,подверженый изменениям.
 * Помечаем нашу переменную этим словом и обозначаем Джаве,что она может быть изменена.
 * Volatile гарантирует когерентность кешей ядер. Наша переменная всегда будет находится в главной памяти ПК,а не
 * на кешах ядер.И потоки в ядрах будут обращаться к главной памяти что бы взять эту переменную в свежем значении.
 *
 *
 * Это ключевое слово необходимо когда одна переменная
 * делиться между несколькими потоками,когда один поток пишет в переменную,а один или более читают из нее
 * Описанный ниже метод по прерыванию потоков может не сработать. По причине плохой когерентности кешей.
 * Допустим 2х ядерный процессор.У каждого ядра свой кеш. И допустим Джава распределила 2 потока на 2 разных ядра.
 * На одном ядре поток MyThread и там есть переменная Running и может случится такое,что этот поток закеширует
 * эту переменную к себе в кеш.И тогда эта переменная всегда будет true.Даже не смотря ,что главный поток Main в
 * другом ядре изменит ее в дальнейшем,второе ядро и поток в котором перменная закешировалась,будет продолжать
 * читать значение переменной Running из своего кеша.И в этом случае этот поток не остановится тке всегда он true
 * Это и есть проблема когерентности(совпадение) кешей. И вот может случится что в мейн переменная Running false,
 *  а в потоке MyThread , во втором ядре она true
 *  Редко очень встречается ,но тем не менее может быть. Не зависит от нас.
 *
 *
 *  И так когда один поток записывает в переменную,а другой читает,то используем на нашей переменной слово volatile
 *  для избежания проблем с когерентностью кешей.
 *
 *
 *
 *
 */
public class Test {
    public static void main(String[] args) {

        MyThread myThread = new MyThread();// пишущий поток потому что изменяет значение переменной с true на false
        myThread.start();

        Scanner scanner = new Scanner(System.in);// создали сканер и задали что при нажатии Enter поток будет прерываться
        scanner.nextLine();// подаем следующую линию в консоли(Enter) и срабатывает shutdown()

        myThread.shutdown();



    }
}

class MyThread extends Thread{// читающий поток
    private volatile boolean running = true;// заводим переменную и помечаем ее ключевым словом volatile

    public void run(){
        while (running){
            System.out.println("Hello");
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }

    public void shutdown(){//создали метод выключающий наш метод и прерывающий поток в бесконечном цикле
        this.running = false;
    }
}
